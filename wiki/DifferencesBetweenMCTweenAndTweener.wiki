#summary Comparison between MC Tween and Tweener
#labels Temp

= Introduction =

[http://hosted.zeh.com.br/mctween/ MC Tween] was an extension for Actionscript 1 and 2. It relied on prototypes to extend the functionality of some built-in Actionscript classes: the `MovieClip`, `TextField` and `Sound` classes. It allowed a developer to create new tweenings easily, with a single line of code.

Tweener is a static Class and, as such, it has many syntactical differences to MC Tween. However, the concept of simplicity - one command only to create a tween - is shared between both these libraries, and of course, both are used for the same intent: creating transitions that usually translate to visual animation.

What follows is a comparison of how both of these libraries work, and how knowledge from MC Tween can be translated to Tweener.


== Syntax differences ==

MC Tween uses a prototype approach, that is, it extends existing classes by adding methods to it.

In MC Tween, the first thing you need to do is `#include` the file, which redefines the classes. You do this with this command, which is added only once to a Flash movie:

{{{
#include "mc_tween2.as"
}}}

After that is done, you can use a bunch of commands to create new tweenings. For example:

{{{
myMC.alphaTo (100, 1, "linear");
myMC.slideTo (10, 10, 1, "linear");
mySound.volumeTo(0, 1);
textField.tween("_x", 10, 1, "easeoutelastic");
}}}

Tweener works by, first, importing the class so it can be properly used. This command is always added before calling the class:

{{{
import class.transitions.Tweener;
}}}

After that is done, Tweener methods can be called.

Now, here's where the main difference lies. First, since Tweener is not based on prototypes, which extend the original classes, you don't call methods from the objects themselves, as in:

{{{
myMC.tween(...);
}}}

Instead, you call Tweener itself, and the object is just the first parameter:

{{{
Tweener.addTween(myMC, ...);
}}}

Also, notice that there are no shortcut methods. With MC Tween, you had methods such as `alphaTo()`, `slideTo`, `alphaTo`, `rotateTo` and many others; however, they were all just shortcuts to `tween()`, meant to make the code easier to understand when reading.

In Tweener, however, only `addTween()` is used. This is meant to make coding less redundant - because of the way the rest of the line is written, it's easy to read and understand what's being tweened, and to which value.

Second, the parameters themselves don't follow a specific order, as they would on MC Tween. In MC Tween, you had something like:

{{{
myMC.tween("_x", 100, 2, "linear", 1);
myMC.xSlideTo(100, 2, "linear", 1);
}}}

Both of the lines above would slide a `myMC` to the column 100, in 2 seconds, with a "linear" transition, and with 1 second delay.

Developers had to remember the order they had to write the parameters, and if they wanted to skip any of them, they had to use a value of `undefined`. Knowing the order beforehand was easy because code hinting was provided, and thus shown immediately after writing the `.tween(` part, but still not very readable.

Tweener, on the other hand, use a tweening "object" for the tweening data. This object holds all [TweeningParameters tweening parameters], in any other, and properties can be omitted where desired. For example, the above line would be written with Tweener as such:

{{{
Tweener.addTween(myMC, {_x:100, time:2, transition:"linear", delay:1});
}}}

The same syntax can be applied when tweening several different properties. For example:

{{{
Tweener.addTween(myMC, {_x:100, _y:10, _alpha:100, time:2, transition:"linear", delay:1});
}}}

This is no magical solution, as remembering the parameters can also be hard, specially for unexperienced developers. In the long run, however, this provides a readable code, even for users not acquainted with Tweener - just reading the line itself is enough to understand what it does, and how.


== Events ==

Other major point of difference between MC Tween and Tweener is how events are handled. With MC Tween, you had one single `callback` function, that was called right after the tweening was finished. For code that would fade a `MovieClip` then hide it completely, it worked as such:

{{{
this.hideMe = function() {
	this._visible = false;
};
myMC.tween("_alpha", 0, 1, "linear", 0, this.hideMe);
}}}

While this works, one of the main issues for me in when using MC Tween in the long run was having some better event management. While you could add event blocks to objects that would be fired when any tween took place on it, it was a pretty clumsy method.

Tweener works by declaring the events together with tweening properties, as such:

{{{
this.hideMe = function() {
	this._visible = false;
};
Tweener.addTween(myMC, {_alpha:0, time:1, transition:"linear", onComplete:hideMe});
}}}

The key point, here, is that you're not only limited to the `onComplete` event, which mimics the way the `callback` parameter worked on MC Tween. You also have other events such as onStart and onComplete, for example:

{{{
this.starting = function() {
	trace ("tweening is starting.");
};
this.updating = function() {
	trace ("tweening has updated.");
};
this.completing = function() {
	trace ("tweening has finished.");
};
Tweener.addTween(myMC, {_x:10, time:1, onStart:this.starting, onUpdate:this.updating, onComplete:this.completing});
}}}

Again, see the [TweeningParameters tweening parameters] page for the complete list.

This might seem overkill, but it is one of the most positive changes from MC Tween to Tweener. Having the ability to set events on tweenings give you the ability to call specific functions every time a tweening is updated - important if you're changing the value of a property that need to be reapplied, like the `redraw()` function of a Class - or when you need to delay some changes to the object and you want to sync them with the start or end of your tweening. This is what gives developers the ability to do very complex tweenings, without the need to wrap it with a lot of code.


== Transitions ==

...


== Special properties ==

...